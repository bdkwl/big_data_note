## NoSQL的三大基石

![NoSQL三基石](https://raw.githubusercontent.com/bdkwl/big_data_note/master/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL%E4%B8%89%E5%9F%BA%E7%9F%B3.png)

### CAP
- C（Consistency）：一致性，指任何一个读操作总是能够读到之前完成的写操作的结果。在分布式环境中，多点的数据是一致的，或者所有节点在同一时间具有相同的数据
- A:（Availability）：可用性，指快速获取数据，可以在确定的时间内返回操作结果，保证每个请求不管成功或者失败都有响应
- P（Tolerance of Network Partition）：分区容忍性，指当出现网络分区的情况时（即系统中的一部分节点无法和其他节点进行通信），分离的系统也能够正常运行。系统中任意信息的丢失或失败不会影响系统的继续运作

CAP理论：一个分布式系统不可能同时满足一致性、可用性和分区容忍性这三个需求，最多只能同时满足其中两个

处理CAP问题的选择：

1. CA：强调一致性（C）和可用性（A），放弃分区容忍性（P）
	
	产品：MySQL、SQL Server、PostgresSQL
	
	最简单的做法是把所有与事务相关的内容都放到同一台机器上。很显然，这种做法会严重影响系统的可扩展性。传统的关系数据库（MySQL、SQL Server和PostgreSQL），都采用了这种设计原则，因此，扩展性都比较差

2. CP：强调一致性（C）和分区容忍性（P），放弃可用性（A）
	
	产品：Neo4J、BigTable、MongoDB、HBase、Redis
	
	当出现网络分区的情况时，受影响的服务需要等待数据一致，因此在等待期间就无法对外提供服务
	
3. AP：强调可用性（A）和分区容忍性（P），放弃一致性（C）
	
	产品：Cassandra
	
	允许系统返回不一致的数据

--- 
	
### BASE

与ACID（关系数据库事务）对比

ACID | BASE
--- | ---
原子性(Atomicity) | 基本可用(Basically Available)
一致性(Consistency) | 软状态/柔性事务(Soft state)
隔离性(Isolation) | 最终一致性 (Eventual consistency)
持久性 (Durable) | 

数据库事务具有ACID四性：

- A（Atomicity）：原子性，是指事务必须是原子工作单元，对于其数据修改，要么全都执行，要么全都不执行
- C（Consistency）：一致性，是指事务在完成时，必须使所有的数据都保持一致状态
- I（Isolation）：隔离性，是指由并发事务所做的修改必须与任何其它并发事务所做的修改隔离
- D（Durability）：持久性，是指事务完成之后，它对于系统的影响是永久性的，该修改即使出现致命的系统故障也将一直保持

BASE的基本含义：

- 基本可用（Basically Availble）
	
	基本可用，是指一个分布式系统的一部分发生问题变得不可用时，其他部分仍然可以正常使用，也就是允许分区失败的情形出现	
- 软状态（Soft-state）
	
	软状态（soft-state）”是与“硬状态（hard-state）”相对应的一种提法。数据库保存的数据是“硬状态”时，可以保证数据一致性，即保证数据一直是正确的。“软状态”是指状态可以有一段时间不同步，具有一定的滞后性
	
- 最终一致性（Eventual consistency）	
	一致性的类型包括强一致性和弱一致性，二者的主要区别在于高并发的数据访问操作下，后续操作是否能够获取最新的数据
	
	强一致性：当执行完一次更新操作后，后续的其他读操作就可以保证读到更新后的最新数据
	
	弱一致性：不能保证后续访问读到的都是更新后的最新数据
	
	最终一致性只不过是弱一致性的一种特例，允许后续的访问操作可以暂时读不到更新后的数据，但是经过一段时间之后，必须最终读到更新后的数据
	
	最常见的实现最终一致性的系统是DNS（域名系统）。一个域名更新操作根据配置的形式被分发出去，并结合有过期机制的缓存；最终所有的客户端可以看到最新的值

---

### 最终一致性
	
最终一致性根据更新数据后各进程访问到数据的时间和方式的不同，又可以区分为：

- 因果一致性
	
	如果进程A通知进程B它已更新了一个数据项，那么进程B的后续访问将获得A写入的最新值。而与进程A无因果关系的进程C的访问，仍然遵守一般的最终一致性规则- “读己之所写”一致性
	
	可以视为因果一致性的一个特例。当进程A自己执行一个更新操作之后，它自己总是可以访问到更新过的值，绝不会看到旧值- 单调读一致性
	
	如果进程已经看到过数据对象的某个值，那么任何后续访问都不会返回在那个值之前的值
	
- 会话一致性
	
	把访问存储系统的进程放到会话（session）的上下文中，只要会话还存在，系统就保证“读己之所写”一致性。如果由于某些失败情形令会话终止，就要建立新的会话，而且系统保证不会延续到新的会话
	
- 单调写一致性
	
	系统保证来自同一个进程的写操作顺序执行。系统必须保证这种程度的一致性，否则就非常难以编程了
	
对于分布式数据系统，实现各种类型的一致性：

N：数据复制的份数 W：更新数据是需要保证	写完成的节点数 R：读取数据时需要读取的节点数

W+R>N：写的节点和读的节点重叠，则是强一致性。例如对于典型的一主一备同步复制的关系型数据库，N=2,W=2,R=1，则不管读的是主库还是备库的数据，都是一致的。**一般设定是R＋W = N+1，这是保证强一致性的最小设定**

W+R<=N：则是弱一致性。例如对于一主一备异步复制的关系型数据库，N=2,W=1,R=1，则如果读的是备库，就可能无法读取主库已经更新过的数据，所以是弱一致性

对于分布式系统，为了保证高可用性，一般设置N>=3。不同的N,W,R组合，是在可用性和一致性之间取一个平衡，以适应不同的应用场景

如果N=W,R=1，任何一个写节点失效，都会导致写失败，因此可用性会降低，但是由于数据分布的N个节点是同步写入的，因此可以保证强一致性

HBase是借助其底层的HDFS来实现其数据冗余备份的。HDFS采用的就是强一致性保证。在数据没有完全同步到N个节点前，写操作是不会返回成功的。也就是说它的W＝N，而读操作只需要读到一个值即可，也就是说它R＝1